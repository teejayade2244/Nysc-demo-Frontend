variables:
  - group: MyProject-Env-Dev

trigger:
  branches:
    include:
      - master 
      - feature/* 
pr:
  branches:
    include:
      - "*" 
resources:
  repositories:
  - repository: GitOpsRepo 
    type: github
    name: teejayade2244/Azure-DevOps-Terraform-Iac 
    ref: master 
    endpoint: github.com_teejayade2244 

pool:
  name: MyLinuxAgents 

stages:
- stage: BuildAndTest
  displayName: 'Build and Test Frontend'
  jobs:
  - job: FrontendCI
    displayName: 'Frontend Continuous Integration (Build, Unit Tests and Dependency scans)'
    pool:
      name: MyLinuxAgents
    steps:
    - task: Bash@3 
      displayName: 'Clean node_modules and package-lock.json for PRs'
      inputs:
        targetType: 'inline'
        script: |
          # Azure DevOps built-in variables for branch name:
          # Build.SourceBranch (e.g., refs/heads/master, refs/pull/123/merge)
          # Build.SourceBranchName (e.g., master, pull/123/merge)
          # System.PullRequest.PullRequestNumber (if it's a PR build)
          
          # Check if it's a PR build by looking for System.PullRequest.PullRequestNumber
          # Or, check if the branch name contains 'pull/'
          if [[ "$(Build.SourceBranch)" == refs/pull/* ]]; then
            echo "This is a PR branch. Cleaning workspace before npm install."
            rm -rf node_modules package-lock.json || true
          else
            echo "Not a PR branch. Skipping pre-install cleanup."
          fi
        workingDirectory: '$(Build.SourcesDirectory)' 

    # Using Node.js Tool Installer task for specific Node.js version
    # ────── Setup and Install ──────
    - task: NodeTool@0
      displayName: 'Use Node.js 22.x' 
      inputs:
        versionSpec: '22.x' 

    - script: npm install --no-audit
      displayName: 'Install Node.js Dependencies'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: |
        echo "Running NPM Audit..."
        npm audit --audit-level=critical
      displayName: 'Run NPM Audit'
      workingDirectory: '$(Build.SourcesDirectory)'

    # ────── OWASP Dependency Check ──────
    # - bash: 'mkdir -p OWASP-security-reports'
    #   displayName: 'Create OWASP Security Reports Directory'
    #   workingDirectory: '$(Build.SourcesDirectory)'
    
    # - task: dependency-check-build-task@6
    #   displayName: 'Run OWASP Dependency Check'
    #   inputs:
    #     projectName: 'core-serve-frontend-app'
    #     scanPath: '$(Build.SourcesDirectory)'
    #     format: 'HTML'
    #     uploadReports: true
    #     failOnCVSS: '8'
    #     enableVerbose: true
    #     nvdApiKey: '$(NVD_API_KEY)' 

    # - task: PublishBuildArtifacts@1
    #   displayName: 'Publish OWASP Reports'
    #   inputs:
    #     pathToPublish: '$(Build.SourcesDirectory)/OWASP-security-reports'
    #     artifactName: 'OWASPReports'

    # Create a directory for test results
    # ────── Unit Tests ──────
    - bash: 'mkdir -p test-results'
      displayName: 'Create Test Results Directory'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: npm test
      displayName: 'Run Unit Tests'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Publish test results (assuming 'npm test' generates a JUnit-compatible report)
    - task: PublishTestResults@2
      displayName: 'Publish Unit Test Results'
      inputs:
        testResultsFormat: 'JUnit' 
        testResultsFiles: '**/junit.xml' 
        mergeResults: true
        failTaskOnFailedTests: true


- stage: SonarQubeAnalysis
  displayName: 'Static Analysis with SonarQube'
  jobs:
  - job: SonarScan
    displayName: 'Run SonarQube Scan'
    pool:
      name: MyLinuxAgents
    steps:
    - task: SonarQubePrepare@5
      displayName: 'Prepare SonarQube Analysis'
      inputs:
          SonarQube: 'sonarqube'
          scannerMode: 'CLI'
          configMode: 'manual'
          cliProjectKey: $(SONARQUBE_PROJECT_KEY)
          cliProjectName: 'temitope'
          extraProperties: |
              sonar.sources=src
              sonar.exclusions=**/node_modules/**,**/bin/**,**/obj/**
            

    - task: SonarQubeAnalyze@5
      displayName: 'Run SonarQube Analysis'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest')) 
     
    - task: SonarQubePublish@5
      displayName: 'Publish SonarQube Results and Wait for Quality Gate'
      inputs:
        pollingTimeoutSec: '300' 
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest')) # This ensures the SonarQube publish step runs only for non-PR builds


- stage: BuildAndScanDockerImage
  displayName: 'Build & Scan Docker Image'
  jobs:
  - job: DockerImageOps
    displayName: 'Docker Image Build & Trivy Scan'
    pool:
      name: MyLinuxAgents
    variables:
      IMAGE_TAG: '$(Build.BuildId)' 
      DOCKER_IMAGE_FULL_NAME: '$(ACR_REGISTRY_SERVER)/$(ACR_REPOSITORY_NAME):$(IMAGE_TAG)'
    steps:
    # Login to Azure Container Registry (ACR)
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        command: 'login'

    # Build and Tag Docker Image
    - task: Docker@2
      displayName: 'Build and Tag Docker Image for ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        repository: '$(ACR_REPOSITORY_NAME)' 
        command: 'build'
        Dockerfile: 'Dockerfile' 
        tags: '$(IMAGE_TAG)' 
        buildContext: '$(Build.SourcesDirectory)' 

    # Trivy Vulnerability Scan
    - bash: 'mkdir -p Trivy-Image-Reports'
      displayName: 'Create Trivy Reports Directory'
      workingDirectory: '$(Build.SourcesDirectory)'

    - script: |
        echo "Running Trivy Scan for MEDIUM severity..."
        trivy image $(DOCKER_IMAGE_FULL_NAME) \
          --severity LOW,MEDIUM \
          --exit-code 0 \
          --quiet \
          --format json -o Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        echo "Running Trivy Scan for CRITICAL severity..."
        trivy image $(DOCKER_IMAGE_FULL_NAME) \
          --severity CRITICAL \
          --exit-code 1 \
          --quiet \
          --format json -o Trivy-Image-Reports/trivy-image-CRITICAL-results.json
      displayName: 'Run Trivy Vulnerability Scan'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Convert Trivy reports to HTML and XML
    # IMPORTANT: Ensure Trivy templates (html.tpl, junit.tpl) are present on your agent at `/usr/local/share/trivy/templates/`.
    - script: |
        echo "Converting Trivy JSON reports to HTML and XML..."
        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/html.tpl" \
          --output Trivy-Image-Reports/trivy-image-MEDIUM-results.html Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/html.tpl" \
          --output Trivy-Image-Reports/trivy-image-CRITICAL-results.html Trivy-Image-Reports/trivy-image-CRITICAL-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/junit.tpl" \
          --output Trivy-Image-Reports/trivy-image-MEDIUM-results.xml Trivy-Image-Reports/trivy-image-MEDIUM-results.json

        trivy convert \
          --format template --template "@/usr/local/share/trivy/templates/junit.tpl" \
          --output Trivy-Image-Reports/trivy-image-CRITICAL-results.xml Trivy-Image-Reports/trivy-image-CRITICAL-results.json
      displayName: 'Convert Trivy Reports'
      workingDirectory: '$(Build.SourcesDirectory)'

    # Publish Trivy reports as build artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Trivy Reports'
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)/Trivy-Image-Reports'
        artifactName: 'TrivyReports'

    # Push Docker Image to ACR
    - task: Docker@2
      displayName: 'Push Docker Image to ACR'
      inputs:
        containerRegistry: 'my-acr-connection' 
        repository: '$(ACR_REPOSITORY_NAME)' 
        command: 'push'
        tags: '$(IMAGE_TAG)'

    # Publish Docker Image as a build artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Docker Image Artifact'
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)/Dockerfile' 
        artifactName: 'DockerImageArtifact'

- stage: K8SImageUpdateStaging
  displayName: 'K8S Image Update'
  dependsOn: BuildAndScanDockerImage
  condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest')) # Run only for PRs
  
  jobs:
  - job: UpdateK8SManifest
    displayName: 'Update K8S Manifest in GitOps Repo'
    pool:
      name: MyLinuxAgents 
    
    variables:
      NEW_IMAGE_TAG: '$(Build.BuildId)'
      PR_SOURCE_BRANCH_NAME: '$(System.PullRequest.SourceBranch)'
  

    steps:
    # Clean the GitOps repository directory to ensure no stale files remain
    - bash: |
        TARGET_CLEAN_DIR="$(Agent.BuildDirectory)/s/kubernetes" 
        echo "Attempting to clean directory: ${TARGET_CLEAN_DIR}"
        if [ -d "${TARGET_CLEAN_DIR}" ]; then
          echo "Removing existing directory: ${TARGET_CLEAN_DIR}"
          rm -rf "${TARGET_CLEAN_DIR}"
        else
          echo "Directory not found, no cleanup needed: ${TARGET_CLEAN_DIR}"
        fi
      displayName: 'Clean GitOps Repo Directory'

    - checkout: GitOpsRepo
      displayName: 'Checkout GitOps Repository'

    # Update the Kubernetes manifest with the new image tag
    - bash: |
        cd "$(Agent.BuildDirectory)/s/kubernetes"
        echo "Current directory: $(pwd)"
        ls -la
        FULL_ACR_IMAGE="${ACR_REGISTRY_SERVER}/${ACR_REPOSITORY_NAME}:${NEW_IMAGE_TAG}"
        echo "DEBUG (Bash-constructed): ACR_REGISTRY_SERVER = ${ACR_REGISTRY_SERVER}"
        echo "DEBUG (Bash-constructed): ACR_REPOSITORY_NAME = ${ACR_REPOSITORY_NAME}"
        echo "DEBUG: NEW_IMAGE_TAG = ${NEW_IMAGE_TAG}"
        echo "DEBUG (Bash-constructed): FULL_ACR_IMAGE = ${FULL_ACR_IMAGE}"
        echo "--- Contents of deployment.yaml BEFORE update ---"
        cat deployment.yaml
        echo "------------------------------------------------"
        git config user.email "temitope224468@gmail.com"
        git config user.name "Azure DevOps Pipeline" 
        TARGET_BRANCH="feature-$(PR_SOURCE_BRANCH_NAME)" 
        echo "Target branch for update: $TARGET_BRANCH"
        # Checkout to the new feature branch. 
        git checkout -b "$TARGET_BRANCH" || git checkout "$TARGET_BRANCH" 

        # Update the 'image' tag in deployment.yaml
        sed -i "s#image: .*#image: ${FULL_ACR_IMAGE}#g" deployment.yaml

        # Verify the changes
        echo "--- Contents of deployment.yaml after update ---"
        cat deployment.yaml
        echo "--------------------------------------------"

        git add deployment.yaml
        git commit -m "Azure DevOps Pipeline: Updated image tag to ${NEW_IMAGE_TAG} for PR $(System.PullRequest.PullRequestId)"
        # Push the changes to the GitOps repository
        echo "Pushing changes to GitOps repository..."
        git push https://$(GITHUB_PAT_FOR_GITOPS)@github.com/teejayade2244/Azure-DevOps-Terraform-Iac.git "$TARGET_BRANCH"
      displayName: 'Update Kubernetes Manifest and Push'
      workingDirectory: '$(Agent.BuildDirectory)' # This is the base directory for the agent's work
